from math import cos, sin, pi
import time
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(int(time.time())) # using unix time as seed

class QuadrotorDynamics:
    '''
    Describes the state of a quadrotor drone, and calcualtes the state derivative/dynamic equations
    Model derived from: https://iopscience.iop.org/article/10.1088/1742-6596/2483/1/012034/pdf


    Member variables:
    -------------------
    position: 
        phi = roll angle between body frame and earth frame
        theta = pitch angle between body frame and earth frame
        psi = yaw angle between body frame and earth frame
        x = x position in earth frame
        y = y position in earth frame
        z = z position in earth frame

    velocity: 
        dphi
        dtheta
        dpsi
        dx
        dy
        dz

    parameters: 
        m = mass
        l = 
        g = gravitational acceleration
        c =
        Jx = inertia around x-axis
        Jy = inertia around y-axis
        Jz = inertia around z-axis

    state is given by:
        Q = (phi, theta, psi, x, y, z, dphi, dtheta, dpsi, dx, dy, dz)
    '''
    
    def __init__(self, position=(0,0,0,0,0,0), velocity=(0,0,0,0,0,0), parameters=(0.96,0.22,9.81,0.000005385,0.0000011,0.0086,0.0086,0.015), drag_coeff=(0,0,0,0,0,0)) -> None:
        if len(position) != 6:
            raise ValueError("Position array must have 6 elements")
        if len(velocity) != 6:
            raise ValueError("Velocity array must have 6 elements")
        if len(parameters) != 8:
            raise ValueError("Parameter array must have 7 elements")
        
        self.phi = position[0]
        self.theta = position[1]
        self.psi = position[2]
        self.x = position[3]
        self.y = position[4]
        self.z = position[5]

        self.dphi = velocity[0]
        self.dtheta = velocity[1]
        self.dpsi = velocity[2]
        self.dx = velocity[3]
        self.dy = velocity[4]
        self.dz = velocity[5]

        self.m = parameters[0]
        self.l = parameters[1]
        self.g = parameters[2]
        self.KT = parameters[3]
        self.KQ = parameters[4]
        self.Jx = parameters[5]
        self.Jy = parameters[6]
        self.Jz = parameters[7]

        # drag_coefficients
        self.K1 = drag_coeff[0] 
        self.K2 = drag_coeff[1]
        self.K3 = drag_coeff[2]
        self.K4 = drag_coeff[3]
        self.K5 = drag_coeff[4]
        self.K6 = drag_coeff[5]

        # summed error used by pid controller
        self.error_sum_phi = 0
        self.error_sum_theta = 0
        self.error_sum_psi = 0
        self.error_sum_z = 0


    def update_position(self, new_position):
        if len(new_position) != 6:
            raise ValueError("New position array must have 6 elements")
        self.phi = new_position[0]
        self.theta = new_position[1]
        self.psi = new_position[2]
        self.x = new_position[3]
        self.y = new_position[4]
        self.z = new_position[5]

    def update_velocity(self, new_velocity):
        if len(new_velocity) != 6:
            raise ValueError("New velocity array must have 6 elements")
        self.dphi = new_velocity[0]
        self.dtheta = new_velocity[1]
        self.dpsi = new_velocity[2]
        self.dx = new_velocity[3]
        self.dy = new_velocity[4]
        self.dz = new_velocity[5]

    def update_state(self, new_position, new_velocity):
        self.update_position(new_position)
        self.update_velocity(new_velocity)
    
    def get_state(self):
        return (self.phi, self.theta, self.psi, self.x, self.y, self.z, self.dphi, self.dtheta, self.dpsi, self.dx, self.dy, self.dz)
    
    def get_velocities(self):
        return (self.dphi, self.dtheta, self.dpsi, self.dx, self.dy, self.dz)

    def get_acceleration(self, U):
        '''
        Uses the current position and velocity, together with the current control input, to calculate the state derivative at the current timestep
        U: current control input, i.e. uses the angular velocity wi of each rotor to describe how the systsem will translate/rotate. 
        Using eq. 20 in the aforementioned paper, we can define the following control inputs:

        U1 = (w1^2 + w2^2 + w3^2 + w4^2) * KT          # vertical thrust generated by the four motors (body frame), 
        U2 = (-w2^2 + w4^2) * KT           
        U3 = (-w1^2 + w3^2) * KT           
        U4 = (w1^2 - w2^2 + w3^2 - w4^2) * KT             
                      

        returns: (ddphi, ddtheta, ddpsi, ddx, ddy, ddz)
        '''
        if len(U) != 4:
            raise ValueError("force input array must have 4 elements")
    
        # Control input vector:
        U1 = U[0]     # vertical thurst
        U2 = U[1]     # pitching moment
        U3 = U[2]     # yawing moment
        U4 = U[3]     # rolling moment       

        # Equations 21 from the paper: 
        ddphi   = self.l *U2 / self.Jx
        ddtheta = self.l * U3 / self.Jy
        ddpsi   = self.KQ * U4 / (self.KT * self.Jz)

        ddx = U1/self.m * (cos(self.phi)*sin(self.theta)*cos(self.psi) + sin(self.phi)*sin(self.psi)) - self.K1*self.dx/self.m
        ddy = U1/self.m * (cos(self.phi)*sin(self.theta)*sin(self.psi) - sin(self.phi)*cos(self.psi)) - self.K2*self.dy/self.m
        ddz = U1/self.m * (cos(self.phi)*cos(self.theta)) - self.g - self.K3*self.dz/self.m

        return (ddphi, ddtheta, ddpsi, ddx, ddy, ddz)
    
    def get_state_derivative(self, U):
        '''
        returns dQ given the specified state dynamics
        dQ = (dphi, dtheta, dpsi, dx, dy, dz, ddphi, ddtheta, ddpsi, ddx, ddy, ddz)
        '''
        return self.get_velocities() + self.get_acceleration(U)

    
    def pid_controller(self, desired_phi, desired_theta, desired_psi, desired_z, desired_dphi=0, desired_dtheta=0, desired_dpsi=0, desired_dz=0):
        '''
        calculates control input given error between current state and desired state
        Note that a quadrotor is under-actuated, so we are only controlling phi, theta, psi and z, while xa dn y are not controlled
        Controller gains retrieved from https://doi.org/10.1007/978-981-15-5341-7_48 page 642, Table 1
        '''
        Kp_phi = 0.009
        Ki_phi = 0.00003
        Kd_phi = 0.08

        Kp_theta = 0.009
        Ki_theta = 0.00003
        Kd_theta = 0.08

        Kp_psi = 0.009
        Ki_psi = 0.00003
        Kd_psi = 0.08

        Kp_z = 13.31
        Ki_z = 0.1
        Kd_z = 25.662

        # Error in z
        error_z = desired_z - self.z
        error_dz = desired_dz - self.dz
        self.error_sum_z += error_z # metning?

        U1 = Kp_z*error_z + Ki_z*self.error_sum_z + Kd_z*error_dz

        # Error in phi
        error_phi = desired_phi - self.phi
        error_dphi = desired_dphi - self.dphi
        self.error_sum_phi += error_phi # metning?

        U2 = Kp_phi*error_phi + Ki_phi*self.error_sum_phi + Kd_phi*error_dphi

        # Error in theta
        error_theta = desired_theta - self.theta
        error_dtheta = desired_dtheta - self.dtheta
        self.error_sum_theta += error_theta # metning?

        U3 = Kp_theta*error_theta + Ki_theta*self.error_sum_theta + Kd_theta*error_dtheta

        # Error in psi
        error_psi = desired_psi - self.psi
        error_dpsi = desired_dpsi - self.dpsi
        self.error_sum_psi += error_psi # metning?

        U4 = Kp_psi*error_psi + Ki_psi*self.error_sum_psi + Kd_psi*error_dpsi


        return (U1, U2, U3, U4)

# Desired trajectories
def get_desired_z(t,mode='step'):
    if mode=='step':
        if t < 2:
            return 0
        return 5
    elif mode =='step_several':
        if t < 2:
            return 0
        elif t < 50:
            return 3
        else:
            return 8
    return 0
        
def get_desired_phi(t,mode='step'):
    if mode=='step':
        if t < 2:
            return 0
        return pi/12
    elif mode =='step_several':
        if t < 2:
            return 0
        elif t < 50:
            return pi/6
        else:
            return pi/12
    return 0

def get_desired_theta(t,mode='step'):
    if mode=='step':
        if t < 2:
            return 0
        return pi/12
    elif mode =='step_several':
        if t < 2:
            return 0
        elif t < 50:
            return pi/6
        else:
            return pi/12
    return 0

def get_desired_psi(t,mode='step'):
    if mode=='step':
        if t < 2:
            return 0
        return pi/12
    elif mode =='step_several':
        if t < 2:
            return 0
        elif t < 50:
            return pi/6
        else:
            return pi/12
    return 0

# Measurement noise
def add_gaussian_noise(array, mean, std_dev):
    noise = np.random.normal(mean, std_dev, size=array.__len__())
    return array + noise

'''
TODO:
legge til modellusikkerheter? kanskje ikke nødvendig hvis man har målestøy på q og u
definere en loop som kan simulere state over tid, gitt et tidsintervall og en initial position/velocity (bruke forward euler?)
lagre trajs til en fil
'''

# SIMULATION PARAMETERS
dt = 1   # time step
tf = 100    # final time
meas_noise_mean = 0       # mean in measurement noise
meas_noise_std_dev = 0.1  # standard deviation in measurement noise

q0 = [0,0,0,0,0,0,0,0,0,0,0,0] # initial state


Q_all = np.array(q0) # state, N+1 * 12 entries
U_all = None # control inputs, N * 4 entries

quadrotor = QuadrotorDynamics(position=q0[0:6], velocity=q0[6:12])

for t in range(0, tf, dt): # time loop start
    desired_phi = get_desired_phi(t)
    desired_theta = get_desired_theta(t)
    desired_psi = get_desired_psi(t)
    desired_z = get_desired_z(t)

    q_t = quadrotor.get_state()                  # state at current time step
    add_gaussian_noise(q_t, meas_noise_mean, meas_noise_std_dev)

    u_t = quadrotor.pid_controller(desired_phi, desired_theta, desired_psi, desired_z) # control input at current timestep
    add_gaussian_noise(u_t, meas_noise_mean, meas_noise_std_dev)

    dq = quadrotor.get_state_derivative(u_t)

    q_t1 = [q_t[i] + dt*dq[i] for i in range(q_t.__len__())]
    Q_all = np.column_stack((Q_all, q_t1))
    print(Q_all)
    if t==0:
        U_all = np.array(u_t)
    else:
        U_all = np.column_stack((U_all, u_t))
# time loop end

plt.plot(range(Q_all[5].__len__()),Q_all[5],label='phi')
plt.xlabel('time')
plt.ylabel('state values (positions)')
plt.show()